<script type="module" >
//import { EffectComposer } from 'EffectComposer';
//import { RenderPass } from 'RenderPass';
//import { GlitchPass } from 'GlitchPass';
//import { OutputPass } from 'OutputPass';
//import * as PIXI from 'pixijs';
import * as THREE from 'three';
import { GLTFLoader } from 'GLTFLoader';
import {CRTFilter} from 'pixifilterCrt';
import {PixelateFilter} from 'pixifilterPixelate';

let HeroComputer;
let Screen;

const _HeroComputer = function(){
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera( 60, 1, .01, 10 );
    const renderer = new THREE.WebGLRenderer({alpha:true,antialias:true});
    const loader = new GLTFLoader();

    const element = $("#HeroComputer");
    const lights = [];

    
    let computerMesh;
    let monitorMesh;
    let screenMesh;
    let chassisMesh;

    let canvasPos = {};

    let currentFrameTime = 0;
    const desiredFPS = 60;
    const frameTimeTarget = 1/desiredFPS;

    let lookPoint = {x:0,y:0};
    let currentRot = new THREE.Vector3(0,0,0);
    let desiredRot = new THREE.Vector3(0,0,0);
    let rotSpeed = .01;

    Init();

    function Animate() {
        currentFrameTime += Time.delta;
        if(currentFrameTime < frameTimeTarget){requestAnimationFrame( Animate ); return;}

        Logic();
        screenMesh.material.emissiveMap.needsUpdate = true;
        renderer.render( scene, camera );
        requestAnimationFrame( Animate );
        currentFrameTime = 0;
        Screen.Render(canvasPos);
    }

    async function Init(){
        SetRandomLookPoint();

        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true;
        renderer.setSize( 500, 500 );

        $(element)[0].appendChild( renderer.domElement );
        GetCanvasPos();
        camera.position.z = 4.5;
        
        BuildLights();
        await AddComputerModel();
        ConfigComputerModel();
        ApplyFaceCanvas();
        Animate();

        $(element).on('mousedown',(e)=>{
            currentRot.x += (Math.floor(Math.random() - .5) + .5) * .5;
            currentRot.y += (Math.floor(Math.random() - .5) + .5) * .5;
            Screen.ShowStatic();
            Screen.Face().Emot('blink',300);
        });
    }

    function GetCanvasPos(){
        const r = $(element)[0].getBoundingClientRect();
        canvasPos.x = r.left + window.scrollX + (r.width/2);
        canvasPos.y = r.top + window.scrollY + (r.height/2);
    }

    function BuildLights(){
        scene.add(new THREE.HemisphereLight(0xffeeb1,0x080820,3));
        AddLight(0xecb2ed,700,{x:-10,y:5,z:10});
        AddLight(0xC6F0C5,700,{x:10,y:5,z:10});
        AddLight(0xecb2ed,700,{x:0,y:-10,z:15});
    }

    async function AddComputerModel(){
        return new Promise((res)=>{
            loader.load( "{{ '/assets/models/computer/computer.glb' | url}}", function ( gltf ) {
                computerMesh = gltf.scene;
                scene.add( computerMesh );
                res();
            });
        });
    }

    function ConfigComputerModel(){
        computerMesh.translateY(-1.7);
        computerMesh.traverse(n => { if ( n.isMesh ) {
            n.castShadow = true;
            n.receiveShadow = true;

            if(n.material.map) n.material.map.anisotropy = 1;
            
            if(n.name == "Screen"){
                screenMesh = n;
            }else if(n.name =="Monitor"){
                monitorMesh = n;
            }else if(n.name == "Chassis"){
                chassisMesh = n;
            }
        }});
    }

    function AddLight(color, intensity, position){
        const light = new THREE.SpotLight(color,intensity);
        light.position.set(position.x,position.y,position.z);
        light.castShadow = true;
        light.shadow.bias = -0.0001;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        lights.push(light);
        scene.add(light);
    }

    function Logic(){
        lookPoint.x = (Mouse.y - canvasPos.y) / 1000;
        lookPoint.y = (Mouse.x - canvasPos.x) / 1000;


        desiredRot.x = lookPoint.x;
        desiredRot.y = lookPoint.y;

        currentRot.x = GetFrameRotInc(currentRot.x,desiredRot.x);
        currentRot.y = GetFrameRotInc(currentRot.y,desiredRot.y);

        monitorMesh.rotation.x = currentRot.x * .2;
        monitorMesh.rotation.y = currentRot.y * .7;
        screenMesh.rotation.x = currentRot.x * .2;
        screenMesh.rotation.y = currentRot.y * .7;
        chassisMesh.rotation.y = currentRot.y * .1;
    }

    function SetRandomLookPoint(){
        const x = Math.random() * 2 - 1;
        const y = Math.random() * 2 - 1;

        $(element.attr('data-yDiv',y));
        $(element.attr('data-xDiv',x));

        const rand = Math.floor(Math.random()*10000) + 1000;
        setTimeout(()=>{
            //SetRandomLookPoint();
        },rand);
    }

    
    function GetFrameRotInc(current,desired){
        const x = current - desired;
        if(Math.abs(x) < .0001){return current;}
        return current - (x/40 * (currentFrameTime * 300));
    }

    function ApplyFaceCanvas(){
        const texture = new THREE.CanvasTexture(Screen.GetView());
        texture.encoding = THREE.sRGBEncoding;
        texture.flipY = false;
        screenMesh.material.map = texture;

        screenMesh.material.emissive = new THREE.Color(0xffffff);
        screenMesh.material.emissiveMap = texture;
        screenMesh.material.emissiveIntensity = 1;
    }
}

const _Screen = function(){
    const app = new PIXI.Application({width: 300, height: 300*.84,background: '#1099bb'});
    const masterContainer = new PIXI.Container();
    const containers = {};
    
    let crtFilter;
    let noiseFilter;
    let pixelateFilter;

    let _face;
    this.Face = ()=>{return _face;}

    Init();

    function Init(){
        document.body.appendChild(app.view);
        app.stage.addChild(masterContainer);

        containers.background = AddContainer(true);
        containers.face = AddContainer(true);
        containers.static = AddContainer();

        PIXI.Assets.addBundle('face',{
            LeftEye_Default: '{{"/assets/images/home/computer/eyel.gif" | url}}',
            RightEye_Default: '{{"/assets/images/home/computer/eyer.gif" | url}}',
            LeftEye_Blink: '{{"/assets/images/home/computer/eyel_blink.gif" | url}}',
            RightEye_Blink: '{{"/assets/images/home/computer/eyer_blink.gif" | url}}',
            Mouth_Default: '{{"/assets/images/home/computer/mouth.gif" | url}}'
        });

        BuildFace();
        BuildFilters();
        BuildContainers();

    }

    async function BuildFace(){
        const bundle = await PIXI.Assets.loadBundle('face');
        _face = new Face(bundle);
    }

    const Face = function(bundle){
        this.Eyes = new Eyes();
        this.Mouth = new Mouths();

        this.Eyes.AddEyes("default",bundle.LeftEye_Default, bundle.RightEye_Default,50,50);
        this.Eyes.AddEyes("blink",bundle.LeftEye_Blink, bundle.RightEye_Blink,50,20);

        this.Eyes.SetEyes("default",true,true,true);

        this.Mouth.AddMouth("default",bundle.Mouth_Default, 75);

        this.Emot = function(name, time){
            this.Eyes.SetEyes(name,true,true,true);
            setTimeout(()=>{
                this.Eyes.SetEyes('default',true,true,true);
            },time);
        }
        this.EyeEmot = function(name,time){

        }
        this.MouthEmot = function(name,time){

        }

        this.Render = (pos) =>{
            this.Eyes.Render(pos);
            this.Mouth.Render(pos);
        }

        let randBlink = Math.random() * 8000 + 500;
        setInterval(()=>{
            this.Emot('blink',100);
            randBlink = Math.random() * 8000 + 500;
        },randBlink);
    }

    const Eyes = function(){
        const DefaultPosition = {x:60,y:120}
        const Left = {};
        const Right = {};

        let lookPosition = {x:0,y:0};
        let currentEyes = {left:"default",right:"default"};


        this.AddEyes = function(key,left,right,w,h){
            Left[key] = new Eye(left,w,h,false);
            Right[key] = new Eye(right,w,h);

            const lX = DefaultPosition.x;
            const rX = app.screen.width - DefaultPosition.x;


            Left[key].Init(lX,DefaultPosition.y);
            Right[key].Init(rX,DefaultPosition.y);
        }

        this.Render = (pos)=>{
            Left[currentEyes.left].MouseOffset(pos).Render();
            Right[currentEyes.right].MouseOffset(pos).Render();
        }

        this.SetEyes = (key,value,left,right) =>{
            if(left){
                Left[currentEyes.left].Visible(false)
                Left[key].Visible(value)
                currentEyes.left = key;
            }
            if(right){
                Right[currentEyes.right].Visible(false)
                Right[key].Visible(value)
                currentEyes.right = key;
            }

        }

    }

    const Mouths = function(){
        const DefaultPosition = {x:app.screen.width/2,y:170};
        const Mouths = {};

        let currentMouth = "default";

        this.AddMouth = function(key,mouth,width){
            Mouths[key] = new Mouth(mouth,width);
            Mouths[key].Init(DefaultPosition.x,DefaultPosition.y);
        }

        this.Render = (pos) =>{
            
            Mouths[currentMouth].MouseOffset(pos).Render();
        }
    }

    const Mouth = function(_asset,_width){
        const asset = _asset;
        const width = _width;

        let defaultPosition = {x:-1000,y:-1000};
        let currentPosition = {x:-1000,y:-1000};
        let offsetPosition = {x:0,y:0};
        let jitterPosition = {x:0,y:0};

        let jitterTime = Time.now;
        let jitterDelta = 0;

        asset.anchor.set(0.5);

        containers.face.addChild(asset);

        this.Init = function(x,y){
            asset.width = width;
            asset.height = width/4;

            defaultPosition.x = x;
            defaultPosition.y = y;
        }

        this.MouseOffset = (pos) =>{
            let x = Mouse.x - pos.x;
            let y = Mouse.y - pos.y;
            console.log(x,y);

            offsetPosition.x = x/25;
            offsetPosition.y = y/12;
            return this;
        }

        this.Render = function(){
            Jitter();
            asset.x = defaultPosition.x + offsetPosition.x + jitterPosition.x;
            asset.y = defaultPosition.y + offsetPosition.y + jitterPosition.y;
        }

                function Jitter(){
            jitterDelta += (Time.now - jitterTime);
            jitterTime = Time.now;
            if(jitterDelta >= 1000/20){
                jitterPosition.x = Math.random() * 4 - 2;
                jitterPosition.y = Math.random() * 4 - 2;
                jitterDelta = 0;
            }
        }
    }

    const Eye = function(_asset, _w,_h, _isRight = true){
        const asset = _asset;
        const defaultSize = {x:_w,y:_h};
        const isRight = _isRight;
        const yOffset = -100;
        const xOffset = 80;

        let defaultPosition = {x:-1000,y:-1000};
        let currentPosition = {x:-1000,y:-1000};
        let offsetPosition = {x:0,y:0};
        let jitterPosition = {x:0,y:0};

        let jitterTime = Time.now;
        let jitterDelta = 0;

        asset.anchor.set(0.5);

        containers.face.addChild(asset);

        asset.visible = false;

        this.Init = function(x,y){
            defaultPosition.x = x;
            defaultPosition.y = y;
            currentPosition = defaultPosition;

            asset.width = defaultSize.x;
            asset.height = defaultSize.y;

            //this.SetPosition();
        }

        this.MouseOffset = (pos) =>{
            let x = (Mouse.x - pos.x - (isRight ? xOffset : (-1*xOffset))) / 1;
            let y = (Mouse.y - pos.y - yOffset) / 1;

            offsetPosition.x = x/25;
            offsetPosition.y = y/10;
            return this;
        }

        this.Render = () => {
            Jitter();
            asset.x = defaultPosition.x + jitterPosition.x + offsetPosition.x;
            asset.y = defaultPosition.y + jitterPosition.y + offsetPosition.y;
        }
        this.Visible = (v) =>{
            asset.visible = v;
        }

        function Jitter(){
            jitterDelta += (Time.now - jitterTime);
            jitterTime = Time.now;
            if(jitterDelta >= 1000/20){
                jitterPosition.x = Math.random() * 4 - 2;
                jitterPosition.y = Math.random() * 4 - 2;
                jitterDelta = 0;
            }
        }
    }

    function BuildFilters(){
        crtFilter = new CRTFilter();
        noiseFilter = new PIXI.NoiseFilter();
        pixelateFilter = new PixelateFilter();

        crtFilter.lineContrast = .3;
        crtFilter.lineWidth = 2
        crtFilter.vignettingAlpha = .6;
        crtFilter.vignettingBlur = .5;

        pixelateFilter.size = 2.4;

        setInterval(()=>{
            crtFilter.time += 1;
            noiseFilter.seed = Math.random();
        },33);
    }

    async function BuildContainers(){
        app.stage.filters = [crtFilter, pixelateFilter];

        const graphics_background = new PIXI.Graphics();
        graphics_background.beginFill(0x664799);
        graphics_background.drawRect(0, 0, app.view.width, app.view.height);
        graphics_background.endFill();
        containers.background.addChild(graphics_background);

        const graphics_static = new PIXI.Graphics();
        graphics_static.beginFill(0x999999);
        graphics_static.drawRect(0, 0, app.view.width, app.view.height);
        graphics_static.endFill();

        containers.static.addChild(graphics_static);
        containers.static.filters = [noiseFilter];
    }

    function AddContainer(visible = false){
        const c = new PIXI.Container();
        c.visible = visible;
        masterContainer.addChild(c);

        return c;
    }

    this.ShowStatic = function(){
        containers.static.visible = true;
        setTimeout(()=>{
            containers.static.visible =false;
        },200)
    }

    this.GetView = function(){
        return app.view;
    }

    this.Render = function(pos){
        _face.Render(pos);
    }

}

document.addEventListener("DOMContentLoaded",()=>{
    HeroComputer = new _HeroComputer();
    Screen = new _Screen();
});
</script>